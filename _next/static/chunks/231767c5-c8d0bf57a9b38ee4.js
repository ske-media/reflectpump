!function(){try{var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},t=(new e.Error).stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="01e58314-1db0-4470-901d-db9306f8342a",e._sentryDebugIdIdentifier="sentry-dbid-01e58314-1db0-4470-901d-db9306f8342a")}catch(e){}}();"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5721],{86534:function(e,t,n){let r;n.d(t,{G_R:function(){return rg},Hnr:function(){return r7},QbW:function(){return eZ},RTE:function(){return oE},UB4:function(){return ez},Xx3:function(){return tK},ZBq:function(){return rL},ZMl:function(){return oO},atr:function(){return nk},cfB:function(){return t3},h8:function(){return oI},jps:function(){return tH},k0l:function(){return tv},m83:function(){return ty},o4J:function(){return oe},oU$:function(){return tG},ogt:function(){return rA},uNj:function(){return rS},v5r:function(){return tp},vMv:function(){return ra},vgT:function(){return eG}});var o,s,a,l,i,u,c,h,d,f,p,y,m,v,b,g,w,S,O,k,j,C,$,T,_,P,A,x,M,I,N,D,R,V,F=n(44838),E=Object.defineProperty,U=(e,t,n)=>t in e?E(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,z=(e,t,n)=>U(e,"symbol"!=typeof t?t+"":t,n);let W=new Map;(o=$||($={})).ApplyPatches="$$applyPatches",o.ApplySnapshot="$$applySnapshot",o.Detach="$$detach",o.ApplySet="$$applySet",o.ApplyDelete="$$applyDelete",o.ApplyMethodCall="$$applyMethodCall",Object.values($),(s=T||(T={})).Sync="sync",s.Async="async",(a=_||(_={})).Spawn="spawn",a.Return="return",a.Resume="resume",a.ResumeError="resumeError",a.Throw="throw";let G=Symbol("modelAction");function L(e){return"function"==typeof e&&G in e}let B="$modelType",J="$modelId";class Q extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Q.prototype)}}function H(e){return new Q(e)}let X={enumerable:!1,writable:!0,configurable:!1,value:void 0};function Y(e,t,n,r=!0){r?(Object.defineProperty(e,t,X),e[t]=n):Object.defineProperty(e,t,{enumerable:!1,writable:r,configurable:!0,value:n})}function Z(e){if(!q(e))return!1;let t=Object.getPrototypeOf(e);return t===Object.prototype||null===t}function q(e){return null!==e&&"object"==typeof e}function K(e){switch(typeof e){case"number":case"string":case"boolean":case"undefined":case"bigint":return!0;default:return null===e}}function ee(e){return e instanceof Map||(0,F.isObservableMap)(e)}function et(e){return e instanceof Set||(0,F.isObservableSet)(e)}function en(e){return Array.isArray(e)||(0,F.isObservableArray)(e)}function er(e,t){if(!q(e))throw H(`${t} must be an object`)}function eo(e,t){if(!(0,F.isObservableArray)(e))throw H(`${t} must be an observable array`)}function es(e,t){if("function"!=typeof e)throw H(`${t} must be a function`)}let ea=Symbol("runAfterNew"),el=Symbol("runBeforeOnInit");function ei(e,t,n){let r=e[t];r&&Object.prototype.hasOwnProperty.call(e,t)||Y(e,t,r=r?r.slice():[]),r.push(n)}function eu(e,t){let n=e[t];if(n)for(let t of n)t(e)}let ec=new Set;function eh(e,t,n){if(n){if(ec.has(n))return;ec.add(n)}switch(t="[mobx-keystone] "+t,e){case"warn":console.warn(t);break;case"error":console.error(t);break;default:throw H(`unknown log type - ${e}`)}}function ed(e){let t;let n=!1;return(...r)=>(n||(t=e(...r),n=!0),t)}let ef=e=>e,ep={makeObservable:F.makeObservable};function ey(){return ep.makeObservable?6:5}let em="mobx-keystone",ev=Symbol("propsType"),eb=Symbol("fromSnapshotOverrideType"),eg=Symbol("toSnapshotOverrideType"),ew=Symbol("modelInitialized"),eS={},eO=new WeakMap;function ek(e,t,n){let r=e.get(t);return void 0===r&&(r=n(),e.set(t,r)),r}let ej=new WeakMap,eC=new WeakMap;function e$(){return(0,F.createAtom)("parentAtom")}function eT(e){var t;null==(t=eC.get(e))||t.reportChanged()}let e_=new WeakMap;function eP(e){let t=e_.get(e);return null!=t?t:e}function eA(e){return rp(e)?e.$:e}let ex=new WeakMap;function eM(e,t){return!(!t&&e_.has(e))&&ex.has(e)}function eI(e){return!K(e)&&eM(e,!1)}function eN(e,t,n=!1){if(!n&&e_.has(e))throw H(`${t} must be the model object instance instead of the '$' sub-object`);if(K(e)||!eM(e,!0))throw H(`${t} must be a tree node (usually a model or a shallow / deep child part of a model 'data' object)`)}let eD=!1,eR=Symbol("modelMetadata"),eV=Symbol("modelUnwrappedClass"),eF=Symbol("runAfterModelDecorator"),eE=Symbol("modelProperties"),eU=Symbol("noDefaultValue"),ez={_setter:!1,_isId:!0,withSetter(e){let t=Object.create(this);return t._setter=null==e||e,t},typedAs:()=>ez},eW={_defaultFn:eU,_defaultValue:eU,_typeChecker:void 0,_setter:!1,_isId:!1,_transform:void 0,_fromSnapshotProcessor:void 0,_toSnapshotProcessor:void 0,withSetter(e){let t=Object.create(this);return t._setter=null==e||e,t},withTransform(e){let t=Object.create(this);return t._transform=function(e){let t=new WeakMap,n=t=>null==t.originalValue?t.originalValue:e.transform(t),r=t=>null==t.transformedValue?t.transformedValue:e.untransform(t);return{transform(e,r,o,s){let a=ek(t,r,()=>new Map),l=a.get(o);(null==l?void 0:l.originalValue)!==e&&(a.delete(o),l=void 0);let i=n({originalValue:e,cachedTransformedValue:null==l?void 0:l.transformedValue,setOriginalValue:s});return a.set(o,{originalValue:e,transformedValue:i}),i},untransform(e,n,o){let s=ek(t,n,()=>new Map);eB=!1;let a=r({transformedValue:e,cacheTransformedValue:eJ});return eB?s.set(o,{originalValue:a,transformedValue:e}):s.delete(o),a}}}(e),t},withSnapshotProcessor({fromSnapshot:e,toSnapshot:t}){let n,r;if(this._fromSnapshotProcessor&&e){let t=this._fromSnapshotProcessor;n=n=>t(e(n))}else n=e||this._fromSnapshotProcessor;if(this._toSnapshotProcessor&&t){let e=this._toSnapshotProcessor;r=n=>t(e(n))}else r=t||this._toSnapshotProcessor;let o=Object.create(this);return o._fromSnapshotProcessor=n,o._toSnapshotProcessor=r,o}};function eG(e){let t=arguments.length>=1;if(!t)return eW;let n=eL.get(e);return n||(n=Object.create(eW),"function"==typeof e?n._defaultFn=e:n._defaultValue=e,eL.set(e,n)),n}let eL=new Map,eB=!1,eJ=()=>{eB=!0};function eQ(e){return e._defaultFn!==eU?e._defaultFn():e._defaultValue!==eU?e._defaultValue:eU}(l=P||(P={})).DevModeOnly="devModeOnly",l.AlwaysOn="alwaysOn",l.AlwaysOff="alwaysOff";let eH=0,eX=((e=21)=>{let t="",n=e;for(;n--;)t+="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[64*Math.random()|0];return t})(),eY={modelAutoTypeChecking:P.DevModeOnly,modelIdGenerator:function(){let e=eH.toString(36)+"-"+eX;return eH++,e},allowUndefinedArrayElements:!1,showDuplicateModelNameWarnings:!0};function eZ(e){eY=Object.freeze({...eY,...e})}function eq(){switch(eY.modelAutoTypeChecking){case P.DevModeOnly:case P.AlwaysOff:return!1;case P.AlwaysOn:return!0;default:throw H(`invalid 'modelAutoTypeChecking' config value - ${eY.modelAutoTypeChecking}`)}}let eK=new WeakMap;function e0(e){let t=eK.get(e);return t||(t={shallow:new Set,shallowAtom:void 0,deep:new Set,deepDirty:!0,deepAtom:void 0,extensionsData:e7()},eK.set(e,t)),t}function e1(e){let t=e0(e);return t.shallowAtom||(t.shallowAtom=(0,F.createAtom)("shallowChildrenAtom")),t.shallowAtom.reportObserved(),t.shallow}function e3(e,t){t.deep.add(e),e5.forEach((n,r)=>{n.addNode(e,t.extensionsData.get(r))})}let e4=(0,F.action)(e=>{var t;let n=e0(e);if(!n.deepDirty)return n;n.deep=new Set,n.extensionsData=e7();let r=n.shallow.values(),o=r.next();for(;!o.done;){e3(o.value,n);let e=e4(o.value).deep.values(),t=e.next();for(;!t.done;)e3(t.value,n),t=e.next();o=r.next()}return n.deepDirty=!1,null==(t=n.deepAtom)||t.reportChanged(),n}),e6=(0,F.action)((e,t)=>{var n;let r=e0(e);r.shallow.add(t),null==(n=r.shallowAtom)||n.reportChanged(),e8(e,r)}),e2=(0,F.action)((e,t)=>{var n;let r=e0(e);r.shallow.delete(t),null==(n=r.shallowAtom)||n.reportChanged(),e8(e,r)});function e8(e,t){var n;let r=e,o=t;for(;r;)o.deepDirty=!0,null==(n=o.deepAtom)||n.reportChanged(),(r=rw(r,!1))&&(o=e0(r))}let e5=new Map;function e9(e){let t={};return e5.set(t,e),e=>e.extensionsData.get(t)}function e7(){let e=new WeakMap;return e5.forEach((t,n)=>{e.set(n,t.initData())}),e}function te(){if(!r)throw H("data changes must be performed inside model actions")}let tt=[],tn=!1;function tr(e){if(rp(e))return e.constructor[eR];if(ry(e))return e[eR];throw H("modelClassOrInstance must be a model class or instance")}let to=new WeakMap;function ts(e){return ek(to,e,()=>tr(e).modelIdProperty)}function ta(e,t,n){return(eN(e,"root"),n===x.ParentFirst)?function(e,t){let n=[e];for(;n.length>0;){let e=n.pop(),r=t(e);if(void 0!==r)return r;let o=e1(e);n.length+=o.size;let s=n.length-1,a=o.values(),l=a.next();for(;!l.done;)n[s--]=l.value,l=a.next()}}(e,t):function e(t,n){let r=e1(t).values(),o=r.next();for(;!o.done;){let t=e(o.value,n);if(void 0!==t)return t;o=r.next()}let s=n(t);if(void 0!==s)return s}(e,t)}(i=A||(A={})).OnInit="$$onInit",i.OnLazyInit="$$onLazyInit",i.OnAttachedToRootStore="$$onAttachedToRootStore",i.OnAttachedToRootStoreDisposer="$$onAttachedToRootStoreDisposer",Object.values(A),(u=x||(x={})).ParentFirst="parentFirst",u.ChildrenFirst="childrenFirst";let tl=new WeakMap,ti=new WeakSet,tu=(0,F.action)("attachToRootStore",(e,t)=>{let n=[];ta(t,e=>{!ti.has(e)&&(ti.add(e),e instanceof rd&&e.onAttachedToRootStore&&(rP(e,"onAttachedToRootStore",A.OnAttachedToRootStore),n.push(e)))},x.ParentFirst);let r=n.length;for(let t=0;t<r;t++){let r=n[t],o=r.onAttachedToRootStore(e);o&&tl.set(r,o)}}),tc=(0,F.action)("detachFromRootStore",e=>{let t=[];ta(e,e=>{if(!ti.delete(e))return;let n=tl.get(e);if(n){let r=r_({nameOrNameFn:A.OnAttachedToRootStoreDisposer,fn:n,actionType:T.Sync}).bind(e);tl.delete(e),t.push(r)}},x.ChildrenFirst);let n=t.length;for(let e=0;e<n;e++)t[e]()}),th=new WeakMap;function td(){return{atom:void 0,is:!1}}let tf=e=>ek(th,e,td),tp=(0,F.action)("registerRootStore",e=>{var t;eN(e,"node");let n=tf(e);if(n.is)throw H("object already registered as root store");if(eN(e,"value"),rw(e,!0))throw H("a root store must not have a parent");return n.is=!0,tu(e,e),null==(t=n.atom)||t.reportChanged(),e});function ty(e){eN(e,"node");let t=tf(e);return t.atom||(t.atom=(0,F.createAtom)("rootStore")),t.atom.reportObserved(),t.is}function tm(e){var t;return!!(null==(t=th.get(e))?void 0:t.is)}function tv(e){eN(e,"node");let t=rO(e,!0);return ty(t)?t:void 0}(0,F.action)("unregisterRootStore",e=>{var t;if(!ty(e))throw H("not a root store");let n=tf(e);n.is=!1,tc(e),null==(t=n.atom)||t.reportChanged()});class tb{constructor(e,t,n,r){z(this,"path"),z(this,"expectedTypeName"),z(this,"actualValue"),z(this,"typeCheckedValue"),z(this,"message"),this.path=e,this.expectedTypeName=t,this.actualValue=n,this.typeCheckedValue=r;let o=[];this.typeCheckedValue&&eM(this.typeCheckedValue,!0)&&(o=function(e,t){let n,r=e,o=[],s=[e];for(;n=rv(r,t);)r=n.parent,o.unshift(n.path),s.unshift(n.parent);return{root:r,path:o,pathObjects:s}}(this.typeCheckedValue,!1).path);let s=eM(this.actualValue,!0)?ra(this.actualValue):this.actualValue;this.message=`TypeCheckError: [/${[...o,...this.path].join("/")}] Expected a value of type <${this.expectedTypeName}> but got the value <${JSON.stringify(s)}> instead`}throw(){throw H(this.message)}}let tg=[],tw=new WeakMap;(c=M||(M={})).Object="object",c.Array="array",c.Primitive="primitive",c.Any="any";let tS=new WeakMap;class tO{constructor(e,t,n,r,o,s,a){z(this,"baseType"),z(this,"_check"),z(this,"getTypeName"),z(this,"typeInfoGen"),z(this,"snapshotType"),z(this,"_fromSnapshotProcessor"),z(this,"_toSnapshotProcessor"),z(this,"checkResultCache"),z(this,"unchecked"),z(this,"_cachedTypeInfoGen"),z(this,"fromSnapshotProcessor",e=>this._fromSnapshotProcessor(e)),z(this,"_toSnapshotProcessorCache",new WeakMap),z(this,"toSnapshotProcessor",e=>{if("object"!=typeof e||null===e)return this._toSnapshotProcessor(e);if(this._toSnapshotProcessorCache.has(e))return this._toSnapshotProcessorCache.get(e);let t=this._toSnapshotProcessor(e);return this._toSnapshotProcessorCache.set(e,t),ek(tS,e,()=>new Set).add(this),t}),this.baseType=e,this._check=t,this.getTypeName=n,this.typeInfoGen=r,this.snapshotType=o,this._fromSnapshotProcessor=s,this._toSnapshotProcessor=a,this.unchecked=!t,this._cachedTypeInfoGen=ed(r)}createCacheIfNeeded(){return this.checkResultCache||(this.checkResultCache=new WeakMap),this.checkResultCache}setCachedResult(e,t){this.createCacheIfNeeded().set(e,t),ek(tw,e,()=>new Set).add(this)}invalidateCachedResult(e){var t;null==(t=this.checkResultCache)||t.delete(e)}getCachedResult(e){var t;return null==(t=this.checkResultCache)?void 0:t.get(e)}check(e,t,n){if(this.unchecked)return null;if(!eM(e,!0))return this._check(e,t,n);let r=this.getCachedResult(e);return(void 0===r&&(r=this._check(e,tg,void 0),this.setCachedResult(e,r)),r)?new tb([...t,...r.path],r.expectedTypeName,r.actualValue,n):null}get typeInfo(){return this._cachedTypeInfoGen(this)}invalidateSnapshotProcessorCachedResult(e){this._toSnapshotProcessorCache.delete(e)}}let tk=Symbol("lateTypeCheker");function tj(e,t){let n;let r=function(){return n||(n=e())};r[tk]=!0;let o=ed(t);return Object.defineProperty(r,"typeInfo",{enumerable:!0,configurable:!1,get:()=>o(r)}),r}function tC(e){return"function"==typeof e&&tk in e}class t${constructor(e){z(this,"thisType"),this.thisType=e}}let tT=new WeakMap,t_=new WeakMap;function tP(e){return tT.get(e)}let tA=(0,F.action)("unsetInternalSnapshot",e=>{var t;let n=tP(e);n&&(tT.delete(e),null==(t=n.atom)||t.reportChanged())}),tx=(0,F.action)("setNewInternalSnapshot",(e,t,n,r=!1)=>{var o;let s=n?n(t):t,a={untransformed:t,transformFn:n,transformed:s,atom:void 0};t_.set(t,r),void 0!==s&&s!==t&&t_.set(s,r),tT.set(e,a),null==(o=a.atom)||o.reportChanged()}),tM=(0,F.action)("updateInternalSnapshot",(e,t)=>{var n;let r=tP(e),o=r.untransformed;t_.get(o)?o=Array.isArray(o)?o.slice():Object.assign({},o):function(e){let t=tS.get(e);t&&(t.forEach(t=>{t.invalidateSnapshotProcessorCachedResult(e)}),tS.delete(e))}(o),t(o),r.untransformed=o,r.transformed=r.transformFn?r.transformFn(o):o,t_.set(r.untransformed,!1),void 0!==r.transformed&&t_.set(r.transformed,!1),null==(n=r.atom)||n.reportChanged();let s=function(e,t){if(!t||!e)return;let n=tP(t.parent);if(n)return{parentSnapshot:n,parentPath:t}}(r,rv(e,!1));if(s){let{parentSnapshot:e,parentPath:t}=s;if(e){let e=t.path;tM(t.parent,t=>{t[e]=r.transformed})}}});function tI(e){if(K(e))return e;let t=t_.get(e);if(void 0===t||t)return e;if(Array.isArray(e))for(let t=0;t<e.length;t++)tI(e[t]);else{let t=Object.keys(e);for(let n=0;n<t.length;n++)tI(e[t[n]])}return t_.set(e,!0),e}let tN=[];class tD{constructor(){z(this,"patches",tN),z(this,"invPatches",tN)}reset(){this.patches=tN,this.invPatches=tN}record(e,t){this.patches=e,this.invPatches=t}emit(e){tR(e,this.patches,this.invPatches),this.reset()}}function tR(e,t,n){(t.length>0||n.length>0)&&(function(e,t,n){for(let r=0;r<tF.length;r++)(0,tF[r])(e,t,n)}(e,t,n),function(e,t,n){let r=[];tE(e,t,n,r);let o=rv(e,!1);for(;o;)r.unshift(o.path),tE(o.parent,t,n,r),o=rv(o.parent,!1)}(e,t,n))}let tV=new WeakMap,tF=[];function tE(e,t,n,r){let o=tV.get(e);if(!o||0===o.length)return;let s=e=>r.length>0?e.map(e=>({...e,path:[...r,...e.path]})):e,a=s(t),l=s(n);for(let e=0;e<o.length;e++)(0,o[e])(a,l)}let tU=e=>{if(K(e))return e;let t=tP(e);return t?tI(t.transformed):e};function tz(e,t,n){return void 0===n?{op:"remove",path:e}:void 0===t?{op:"add",path:e,value:tU(n)}:{op:"replace",path:e,value:tU(n)}}function tW(e,t,n){e[t]===n&&t in e||(0,F.set)(e,t,n)}function tG(e,t,n=0){let r=function(e,t,n=0){let r;eN(e,"child");let o=[],s=e,a=0;for(;r=rv(s,!0);){if(o.unshift(r.path),t(s=r.parent))return{parent:s,path:o};if(a++,n>0&&a===n)break}}(e,t,n);return r?r.parent:void 0}(h=I||(I={}))[h.Model=0]="Model",h[h.Array=1]="Array",h[h.PlainObject=2]="PlainObject",h[h.Frozen=3]="Frozen";let tL=!0;function tB(e){let t=tL;tL=!1;try{e()}finally{tL=t}}(d=N||(N={}))[d.Array=0]="Array",d[d.Frozen=1]="Frozen",d[d.Model=2]="Model",d[d.PlainObject=3]="PlainObject",(f=D||(D={})).DevModeOnly="devModeOnly",f.On="on",f.Off="off";let tJ="$frozen";class tQ{constructor(e,t=D.DevModeOnly){z(this,"data");let n=t===D.On;n&&function e(t){if(!K(t)){if(Array.isArray(t)){let n=t.length;for(let r=0;r<n;r++){let n=t[r];if(void 0===n&&!eY.allowUndefinedArrayElements)throw H("undefined is not supported inside arrays since it is not serializable in JSON, consider using null instead");e(n)}Object.freeze(t);return}if(Z(t)){let n=Object.keys(t),r=n.length;for(let o=0;o<r;o++){let r=n[o],s=t[r];e(r),e(s)}Object.freeze(t);return}throw H(`frozen data must be plainly serializable to JSON, but ${t} is not`)}}(e),this.data=e,n&&Object.freeze(this.data),nD(this,void 0)}}function tH(e,t=D.DevModeOnly){return new tQ(e,t)}function tX(e){return Z(e)&&tJ in e}let tY=(p=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t instanceof Map&&n instanceof Map){if(t.size!==n.size)return!1;for(o of t.entries())if(!n.has(o[0]))return!1;for(o of t.entries())if(!e(o[1],n.get(o[0])))return!1;return!0}if(t instanceof Set&&n instanceof Set){if(t.size!==n.size)return!1;for(o of t.entries())if(!n.has(o[0]))return!1;return!0}if(ArrayBuffer.isView(t)&&ArrayBuffer.isView(n)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(t[o]!==n[o])return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(s=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,s[o]))return!1;for(o=r;0!=o--;){var r,o,s,a=s[o];if(!e(t[a],n[a]))return!1}return!0}return t!=t&&n!=n}).__esModule&&Object.prototype.hasOwnProperty.call(p,"default")?p.default:p;class tZ{constructor(e){var t;z(this,"pool"),e=null!=(t=e_.get(e))?t:e,this.pool=tq(function(e){let t=e0(e);return t.deepDirty&&e4(e),t.deepAtom||(t.deepAtom=(0,F.createAtom)("deepChildrenAtom")),t.deepAtom.reportObserved(),t}(e))}findModelByTypeAndId(e,t){return t?this.pool.get(e+" "+t):void 0}findModelForSnapshot(e){if(!rm(e))return;let t=e[B],n=ts(eS[t].class);return n?this.findModelByTypeAndId(t,e[n]):void 0}}let tq=e9({initData:()=>new Map,addNode(e,t){if(rp(e)){let n=e[J];n&&t.set(e[B]+" "+n,e)}}});function tK(e,t){eN(e,"node"),er(t,"snapshot"),t1().call(e,t)}function t0(e){let t=this,n=()=>{let n=new tZ(t);t9(t,e,n,void 0)};if(en(e)){if(!en(t))throw H("if the snapshot is an array the target must be an array too");n();return}if(tX(e))throw H("applySnapshot cannot be used over frozen objects");if(Z(e)&&void 0===e[B]&&rp(t)){let n=eO.get(t.constructor);e={...e,[B]:n.name}}if(rm(e)){let r=e[B],o=eS[r];if(!o)throw H(`model with name "${r}" not found in the registry`);if(!rp(t))throw H("the target for a model snapshot must be a model instance");if(t[B]!==r)throw H(`snapshot model type '${r}' does not match target model type '${t[B]}'`);let s=ts(o.class);if(s){let n=e[s];if(t[J]!==n)throw H(`snapshot model id '${n}' does not match target model id '${t[J]}'`)}n();return}if(Z(e)){if(!Z(t)&&!(0,F.isObservableObject)(t))throw H("if the snapshot is an object the target must be an object too");n();return}if(ee(e))throw H("a snapshot must not contain maps");if(et(e))throw H("a snapshot must not contain sets");throw H(`unsupported snapshot - ${e}`)}let t1=ed(()=>r_({nameOrNameFn:$.ApplySnapshot,fn:t0,actionType:T.Sync}));function t3(e,t){let n="function"==typeof e?e:()=>e,r=n();eN(r,"node");let o=ra(r);return(0,F.reaction)(()=>ra(n()),e=>{let n=o;o=e,t(e,n)})}function t4(e,t){return e===t||(eI(e)?e=ra(e):(0,F.isObservable)(e)&&(e=(0,F.toJS)(e,t6)),eI(t)?t=ra(t):(0,F.isObservable)(t)&&(t=(0,F.toJS)(t,t6)),tY(e,t))}let t6=ey()>=6?void 0:{exportMapsAsObjects:!1,recurseEverything:!1},t2=!1,t8=[];function t5(e,t){t8.push({priority:e,reconciler:t}),t8.sort((e,t)=>e.priority-t.priority)}function t9(e,t,n,r){if(K(t))return t;if(ra(e)===t)return e;t2||(t2=!0,t5(N.Array,(e,t,n)=>{if(en(t))return function(e,t,n){if(!en(e))return nk(t);let r=ra(e);return tB(()=>{e.length>t.length&&e.splice(t.length,e.length-t.length);for(let r=0;r<e.length;r++){let o=e[r],s=t9(o,t[r],n,e);t7(s,o,n),tW(e,r,s)}for(let r=e.length;r<t.length;r++)e.push(t9(void 0,t[r],n,e))}),no(e,void 0,r),e}(e,t,n)}),t5(N.Frozen,(e,t)=>{if(tX(t))return e instanceof tQ&&e.data===t.data?e:tH(t.data)}),t5(N.Model,(e,t,n,r)=>{if(rm(t))return function(e,t,n,r){let o=t[B],s=eS[o];if(!s)throw H(`model with name "${o}" not found in the registry`);let a=n.findModelForSnapshot(t);if(a&&(e=a),!rp(e)||e[B]!==o)return nk(t);let l=s.class,i=l[eE],u=ts(l);if(u){let n=t[u];if(e[J]!==n)return nk(t)}else if(en(r)&&!t4(e,t))return nk(t);let c=e,h=ra(c);return tB(()=>{let e=c.constructor,r=e.fromSnapshotProcessor?e.fromSnapshotProcessor(t):t,o=c.$,s=Object.keys(o),a=s.length;for(let e=0;e<a;e++){let t=s[e];if(!(t in r)){let e=i[t],n=e?eQ(e):eU;n===eU?(0,F.remove)(o,t):tW(o,t,n)}}let l=Object.keys(r),u=l.length;for(let e=0;e<u;e++){let t=l[e];if(t!==B){let e=r[t],s=o[t],a=t9(s,e,n,c);if(null==a){let e=i[t],n=e?eQ(e):eU;n!==eU&&(a=n)}t7(a,s,n),tW(o,t,a)}}}),no(c,void 0,h),c}(e,t,n,r)}),t5(N.PlainObject,(e,t,n)=>{if(Z(t))return function(e,t,n){if(!Z(e)&&!(0,F.isObservableObject)(e))return nk(t);let r=ra(e);return tB(()=>{let r=Object.keys(e),o=r.length;for(let n=0;n<o;n++){let o=r[n];o in t||(0,F.remove)(e,o)}let s=Object.keys(t),a=s.length;for(let r=0;r<a;r++){let o=s[r],a=t[o],l=e[o],i=t9(l,a,n,e);t7(i,l,n),tW(e,o,i)}}),no(e,void 0,r),e}(e,t,n)}));let o=t8.length;for(let s=0;s<o;s++){let{reconciler:o}=t8[s],a=o(e,t,n,r);if(void 0!==a)return a}if(ee(t))throw H("a snapshot must not contain maps");if(et(t))throw H("a snapshot must not contain sets");throw H(`unsupported snapshot - ${t}`)}function t7(e,t,n){if(e!==t&&rp(e)&&n.findModelByTypeAndId(e[B],e[J])){let t=rb(e,!1);t&&(0,F.set)(t.parent,t.path,null)}}function ne(e,t,n=!1){eN(e,"node"),t.length<=0||nn().call(e,t,n)}function nt(e,t=!1){let n=new tZ(this);if(t){let t=e.length;for(;t--;){let r=e[t];if(en(r)){let e=r.length;for(;e--;)nr(this,r[e],n)}else nr(this,r,n)}}else{let t=e.length;for(let r=0;r<t;r++){let t=e[r];if(en(t)){let e=t.length;for(let r=0;r<e;r++)nr(this,t[r],n)}else nr(this,t,n)}}}let nn=ed(()=>r_({nameOrNameFn:$.ApplyPatches,fn:nt,actionType:T.Sync}));function nr(e,t,n){let{target:r,prop:o}=function(e,t){let n=eA(e);if(0===t.length)return{target:n};for(let e=0;e<=t.length-2;e++)n=eA(n[t[e]]);return{target:n,prop:t[t.length-1]}}(e,t.path);if(en(r))switch(t.op){case"add":{let e=+o,s=t9(void 0,t.value,n,r);e<0?r.push(s):r.splice(e,0,s);break}case"remove":{let e=+o;r.splice(e,1);break}case"replace":if("length"===o)r.length=t.value;else{let e=+o,s=t9(r[e],t.value,n,r);tW(r,e,s)}break;default:throw H(`unsupported patch operation: ${t.op}`)}else switch(t.op){case"add":{let e=t9(void 0,t.value,n,r);tW(r,o,e);break}case"remove":(0,F.remove)(r,o);break;case"replace":{let e=t9(r[o],t.value,n,r);tW(r,o,e);break}default:throw H(`unsupported patch operation: ${t.op}`)}}function no(e,t,n){if(tL&&(!function(e){let t=e;for(;t;){let e=tw.get(t);e&&(tw.delete(t),e.forEach(e=>{e.invalidateCachedResult(t)})),t=function(e,t){var n;return null==(n=rb(e,t))?void 0:n.parent}(t,!1)}}(e),eq())){let r=function(e){let t=eP(e);return e!==t&&rp(e=t)&&tr(e).dataType?e:tG(e,e=>rp(e)&&!!tr(e).dataType)}(e);if(r){let o=r.typeCheck();o&&(!function(e){let t=eD;eD=!0;try{(0,F.runInAction)(()=>{e()})}finally{eD=t}}(()=>{t?nt.call(e,t.invPatches,!0):n&&t0.call(e,n)}),o.throw())}}}function ns(e,t,n){let r,o;let s=e.length,a=(0,F.isObservableArray)(e)?e:F.observable.array(void 0,nh);a!==e&&(a.length=e.length),ex.set(a,()=>{r(),o()}),n_(a,t,!1,!1,!1);let l=[];l.length=s;for(let t=0;t<s;t++){let r=e[t];if(K(r))n||tW(a,t,r),l[t]=r;else{let e;let o={parent:a,path:t};n?n_(e=r,o,!1,!1,!1):tW(a,t,e=nD(r,o));let s=tP(e);l[t]=s.transformed}}return tx(a,l,void 0),r=(0,F.intercept)(a,nc.bind(void 0,a)),o=(0,F.observe)(a,nu),a}function na(e,t,n){n[e]=t}function nl(e,t,n,r){r.splice(e,t,...n)}let ni=new tD;function nu(e){let t;let n=e.object,r=tP(n).untransformed;switch(ni.reset(),e.type){case"splice":t=function(e,t){let n=e.index,r=e.addedCount,o=e.removedCount,s=[];s.length=r;for(let t=0;t<r;t++){let n=e.added[t];K(n)?s[t]=n:s[t]=tP(n).transformed}let a=t.length,l=nl.bind(void 0,n,o,s),i=[],u=[];if(r===o){let e=[],a=[],l=0;for(let c=0;c<r;c++){let r=n+c,h=nd(t,r,n,o,s),d=t[r];if(h!==d){let t=[r-l];i.push({op:"remove",path:t}),u.push({op:"remove",path:t}),l++;let n=[r];e.push({op:"add",path:n,value:tI(h)}),a.push({op:"add",path:n,value:tI(d)})}}i.push(...e),u.push(...a),u.reverse()}else{let e=a-o;if(o>0){let r=n>=e;r&&i.push({op:"replace",path:["length"],value:e});for(let e=o-1;e>=0;e--){let o=n+e,s=[o];r||i.push({op:"remove",path:s}),u.push({op:"add",path:s,value:tI(t[o])})}}if(r>0){let a=n>=e;a&&u.push({op:"replace",path:["length"],value:e});for(let e=0;e<r;e++){let r=n+e,l=[r];i.push({op:"add",path:l,value:tI(nd(t,r,n,o,s))}),a||u.push({op:"remove",path:l})}}}return ni.record(i,u),l}(e,r);break;case"update":t=function(e,t){let n;let r=e.index,o=e.newValue,s=t[r];n=K(o)?o:tP(o).transformed;let a=na.bind(void 0,r,n),l=[r];return ni.record([{op:"replace",path:l,value:tI(n)}],[{op:"replace",path:l,value:tI(s)}]),a}(e,r)}no(n,ni),!eD&&t&&(tM(n,t),ni.emit(n))}function nc(e,t){switch(te(),t.type){case"splice":!function(e){for(let t=0;t<e.removedCount;t++)nD(e.object[e.index+t],void 0);for(let t=0;t<e.added.length;t++)e.added[t]=nD(e.added[t],{parent:e.object,path:e.index+t});let t=e.index+e.removedCount,n=e.index+e.added.length;if(t!==n)for(let r=t,o=n;r<e.object.length;r++,o++)n_(e.object[r],{parent:e.object,path:o},!0,!1,!1)}(t);break;case"update":nD(e[t.index],void 0),t.newValue=nD(t.newValue,{parent:e,path:t.index})}return t}let nh={deep:!1};function nd(e,t,n,r,o){let s=t-n;return s<0?e[t]:s<o.length?o[s]:e[t-o.length+r]}function nf(e,t,n,r,o){let s,a,l;let i=(0,F.isObservableObject)(e)?e:F.observable.object({},void 0,np);ex.set(i,()=>{s(),a()}),n_(i,t,!1,o,!1);let u={},c=Object.keys(e),h=c.length;for(let t=0;t<h;t++){let n=c[t],o=e[n];if(K(o))r||tW(i,n,o),u[n]=o;else{let e;let t={parent:i,path:n};r?n_(e=o,t,!1,!1,!1):tW(i,n,e=nD(o,t));let s=tP(e);u[n]=s.transformed}}if(n){u[B]=n;let e=eS[n];if(!e)throw H(`model with name "${n}" not found in the registry`);let t=e.class.toSnapshotProcessor;t&&(l=e=>t(e,eP(i)))}return tx(o?eP(i):i,u,l),s=(0,F.intercept)(i,ng),a=(0,F.observe)(i,nb),i}let np={deep:!1};function ny(e,t,n){n[e]=t}function nm(e,t){delete t[e]}let nv=new tD;function nb(e){let t;let n=e.object,r=eP(n),o=tP(r).untransformed;switch(nv.reset(),e.type){case"add":case"update":t=function(e,t){let n;let r=e.name,o=e.newValue,s=t[r];n=K(o)?o:tP(o).transformed;let a=ny.bind(void 0,r,n),l=[r];return"add"===e.type?nv.record([{op:"add",path:l,value:tI(n)}],[{op:"remove",path:l}]):nv.record([{op:"replace",path:l,value:tI(n)}],[{op:"replace",path:l,value:tI(s)}]),a}(e,o);break;case"remove":t=function(e,t){let n=e.name,r=t[n],o=nm.bind(void 0,n),s=[n];return nv.record([{op:"remove",path:s}],[{op:"add",path:s,value:tI(r)}]),o}(e,o)}no(n,nv),eD||(tM(r,t),nv.emit(r))}function ng(e){if(te(),"symbol"==typeof e.name)throw H("symbol properties are not supported");switch(e.type){case"add":e.newValue=nD(e.newValue,{parent:e.object,path:String(e.name)});break;case"remove":nD(e.object[e.name],void 0);break;case"update":{let t=e.object[e.name],n=e.newValue;n!==t&&(nD(t,void 0),e.newValue=nD(n,{parent:e.object,path:String(e.name)}))}}return e}let nw=!1,nS=[];function nO(e,t){nS.push({priority:e,snapshotter:t}),nS.sort((e,t)=>e.priority-t.priority)}function nk(e,t,n){let r,o,s;if(tC(e)||e instanceof tO||ry(e)){let a=rr(e);o=t,r=a.fromSnapshotProcessor(o),s=n}else o=r=e,s=t;return nj(r,o,s)}let nj=(0,F.action)("fromSnapshot",(e,t,n)=>{let r={options:{generateNewIds:!1,overrideRootModelId:void 0,...n},untypedSnapshot:t};return r.snapshotToInitialData=n$.bind(void 0,r),nC(e,r)});function nC(e,t){if(K(e))return e;nw||(nw=!0,nO(N.Array,(e,t)=>{if(en(e))return function(e,t){let n=F.observable.array([],nT),r=e.length;for(let o=0;o<r;o++)n.push(nC(e[o],t));return ns(n,void 0,!0)}(e,t)}),nO(N.Frozen,e=>{if(tX(e))return tH(e.data)}),nO(N.Model,(e,t)=>{if(rm(e))return function(e,t){let n=e[B];if(!n)throw H(`a model snapshot must contain a type key (${B}), but none was found`);let r=eS[n];if(!r)throw H(`model with name "${n}" not found in the registry`);let o=ts(r.class);if(o&&void 0===e[o])throw H(`a model snapshot of type '${n}' must contain an id key (${o}), but none was found`);return new r.class(void 0,{snapshotInitialData:{unprocessedSnapshot:e,unprocessedModelType:"object"==typeof t.untypedSnapshot&&t.untypedSnapshot&&B in t.untypedSnapshot?t.untypedSnapshot[B]:void 0,snapshotToInitialData:t.snapshotToInitialData},generateNewIds:t.options.generateNewIds})}(e,t)}),nO(N.PlainObject,(e,t)=>{if(Z(e))return function(e,t){let n=F.observable.object({},void 0,nT),r=Object.keys(e),o=r.length;for(let s=0;s<o;s++){let o=r[s],a=e[o];(0,F.set)(n,o,nC(a,t))}return nf(n,void 0,void 0,!0,!1)}(e,t)}));let n=nS.length;for(let r=0;r<n;r++){let{snapshotter:n}=nS[r],o=n(e,t);if(void 0!==o)return o}if(ee(e))throw H("a snapshot must not contain maps");if(et(e))throw H("a snapshot must not contain sets");throw H(`unsupported snapshot - ${e}`)}function n$(e,t){let n=F.observable.object({},void 0,nT),r=Object.keys(t),o=r.length;for(let s=0;s<o;s++){let o=r[s];if(o!==B){let r=t[o];(0,F.set)(n,o,nC(r,e))}}return n}let nT={deep:!1},n_=(0,F.action)("setParent",(e,t,n,o,s)=>{var a,l,i;let u,c;if(K(e))return e;let h=rv(e,!1);if(a=h,l=t,!a&&!l||a&&l&&a.parent===l.parent&&a.path===l.path)return e;if(tm(e))throw H("root stores cannot be attached to any parents");if(o)return e_.set(e,t.parent),e;if(t){let e=eP(t.parent);t.parent!==e&&(t={parent:e,path:t.path})}if(s&&(null==t?void 0:t.parent)&&(null==h?void 0:h.parent)&&rp(e)&&tr(e).valueType&&(h=rv(e=function(e,t){eN(e,"node");let n={generateNewIds:!0,...t};return nk(ra(e),n)}(e,{generateNewIds:!0}),!1)),h&&t){if(h.parent===t.parent&&n)return ej.set(e,t),eT(e),e;throw H("an object cannot be assigned a new parent when it already has one")}let d=t?void 0:function(e){if(K(e))return;let t=ex.get(e);if(!t)return;let n=Array.from(e1(e).values());for(let e=0;e<n.length;e++)n_(n[e],void 0,!1,!1,!1);return()=>{t(),ex.delete(e),tA(e)}}(e),f=e instanceof rd;if(f&&(c=tm(u=rO(e,!1))?u:void 0),(null==h?void 0:h.parent)&&e2(h.parent,e),ej.set(e,t),(null==t?void 0:t.parent)&&e6(t.parent,e),eT(e),f){let t=rO(e,!1),n=tm(t)?t:void 0;c!==n&&(c||n)&&(i=()=>{c&&tc(e),n&&tu(n,e)},r?tt.push(i):i())}return null==d||d(),e});function nP(e,t){let n=rr(e);return n.unchecked?null:n.check(t,[],t)}function nA(e,t){return ex.set(e,void 0),n_(e,t,!1,!1,!0),e}let nx=!1;function nM(e,t){let n,r,o;if(1==arguments.length?(o=!1,n=e):(r=e,o=!0,n=t),!q(n))throw H("only objects can be turned into tree nodes");if(o&&eq()){let e=nP(r,n);e&&e.throw()}return eM(n,!0)?n:nD(n,void 0)}let nI=[];function nN(e,t){nI.push({priority:e,tweaker:t}),nI.sort((e,t)=>e.priority-t.priority)}let nD=(0,F.action)("tweak",function(e,t){if(K(e))return e;if(eM(e,!0))return e=n_(e,t,!1,!1,!0);if(nW(e))throw H("data models are not directly supported. you may insert the data in the tree instead ('$' property).");nx||(nx=!0,nN(I.Array,(e,t)=>{if(en(e))return ns(e,t,!1)}),nN(I.Frozen,(e,t)=>{if(e instanceof tQ)return ex.set(e,void 0),n_(e,t,!1,!1,!1),tx(e,{[tJ]:!0,data:e.data},void 0,!0),e}),nN(I.Model,(e,t)=>{if(rp(e))return nA(e,t)}),nN(I.PlainObject,(e,t)=>{if((0,F.isObservableObject)(e)||Z(e))return nf(e,t,void 0,!1,!1)}));let n=nI.length;for(let r=0;r<n;r++){let{tweaker:n}=nI[r],o=n(e,t);if(void 0!==o)return o}if(ee(e))throw H("maps are not directly supported. consider using 'ObjectMap' / 'asMap' instead.");if(et(e))throw H("sets are not directly supported. consider using 'ArraySet' / 'asSet' instead.");throw H(`tweak can only work over models, observable objects/arrays, or primitives, but got ${e} instead`)}),nR=Symbol("modelInitializers");function nV(e,t){let n=e[nR];if(n){let e=n.length;for(let r=0;r<e;r++)n[r](t)}}let nF=(0,F.action)("newModel",(e,t,n)=>{let{modelClass:r}=n;if(!eO.get(r))throw H(`no model info for class ${r.name} could be found - did you forget to add the @model decorator?`);if(e.$=t,nV(r,e),eq()&&nL(r).dataType){let t=e.typeCheck();t&&t.throw()}return e}),nE=new WeakMap;class nU{constructor(e){let t;if(z(this,ev),z(this,"$"),!q(e))throw H("data models can only work over data objects");let{modelClass:n}=arguments[1];if(eI(e))t=e;else{if(!eO.get(n))throw H(`no model info for class ${n.name} could be found - did you forget to add the @model decorator?`);let r=n[eE],o=Object.assign({},e),s=Object.keys(r);for(let e=0;e<s.length;e++){let t=s[e],n=r[t],a=o[t],l=!1;n._transform&&(l=!0,a=n._transform.untransform(a,this,t)),null==a&&(n._defaultFn!==eU?(l=!0,a=n._defaultFn()):n._defaultValue!==eU&&(l=!0,a=n._defaultValue)),l&&(o[t]=a)}t=nM(o)}let r=ek(nE,n,()=>new WeakMap),o=r.get(t);if(o)return o;r.set(t,this),Object.setPrototypeOf(this,n.prototype),delete this[ev],nF(this,t,{modelClass:n})}typeCheck(){return nP(nQ(this.constructor),this.$)}toString(e){let t={withData:!0,...e},n=eO.get(this.constructor),r=`${this.constructor.name}#${n.name}`;return t.withData?`[${r} ${JSON.stringify(ra(this))}]`:`[${r}]`}}let nz=new Set(["onLazyInit","$","typeCheck"]);function nW(e){return e instanceof nU}function nG(e){return"function"==typeof e&&(e===nU||e.prototype instanceof nU)}function nL(e){if(nW(e))return e.constructor[eR];if(nG(e))return e[eR];throw H("modelClassOrInstance must be a model class or instance")}function nB(e){let t=rs(e).typeInfo;if(!t)throw H(`type info not found for ${e}`);return t}let nJ=new WeakMap;function nQ(e){if(!nG(e)&&"function"==typeof e)return tj(()=>nQ(e()),t=>new nH(t,e()));{let t=nJ.get(e);if(t)return t;let n=t=>new nH(t,e),r=tj(()=>{let t=eO.get(e),r=`DataModelData(${t.name})`,o=nL(e).dataType;if(!o)throw H(`type checking cannot be performed over data model data of type '${t.name}' since that model type has no data type declared, consider adding a data type or using types.unchecked() instead`);let s=rr(o),a=new tO(M.Object,(e,t,n)=>s.check(e,t,n),()=>r,n,e=>s.snapshotType(e)?a:null,e=>s.fromSnapshotProcessor(e),e=>s.toSnapshotProcessor(e));return a},n);return nJ.set(e,r),r}}class nH extends t${constructor(e,t){super(e),z(this,"modelClass"),z(this,"_props",ed(()=>{let e=this.modelClass[eE],t={};return Object.keys(e).forEach(n=>{let r,o;let s=e[n],a=s._typeChecker;a&&(r=nB(a));let l=!1;s._defaultFn!==eU?(o=s._defaultFn,l=!0):s._defaultValue!==eU&&(o=s._defaultValue,l=!0),t[n]={type:a,typeInfo:r,hasDefault:l,default:o}}),t})),this.modelClass=t}get props(){return this._props()}get modelType(){return eO.get(this.modelClass).name}}let nX=new WeakMap;function nY(e){if(!ry(e)&&"function"==typeof e)return tj(()=>nY(e()),t=>new nZ(t,e()));{let t=nX.get(e);if(t)return t;let n=t=>new nZ(t,e),r=tj(()=>{let t=eO.get(e),r=`Model(${t.name})`,o=tr(e).dataType,s=o?rr(o):void 0,a=new tO(M.Object,(t,n,o)=>t instanceof e?s?s.check(t.$,n,o):null:new tb(n,r,t,o),()=>r,n,e=>q(e)?void 0!==e[B]?e[B]===t.name?a:null:s&&s.snapshotType(e)?a:null:null,e=>e[B]?e:{...e,[B]:t.name},e=>e);return a},n);return nX.set(e,r),r}}class nZ extends t${constructor(e,t){super(e),z(this,"modelClass"),z(this,"_props",ed(()=>{let e=this.modelClass[eE],t={};return Object.keys(e).forEach(n=>{let r,o;let s=e[n],a=s._typeChecker;a&&(r=nB(a));let l=!1;s._defaultFn!==eU?(o=s._defaultFn,l=!0):s._defaultValue!==eU&&(o=s._defaultValue,l=!0),t[n]={type:a,typeInfo:r,hasDefault:l,default:o}}),t})),this.modelClass=t}get props(){return this._props()}get modelType(){return eO.get(this.modelClass).name}}let nq=[];function nK(e){let t;switch(!function(e,t){if(!K(e))throw H(`${t} must be a primitive`)}(e,"literal"),e){case void 0:t="undefined";break;case null:t="null";break;default:t=JSON.stringify(e)}let n=new tO(M.Primitive,(n,r,o)=>n===e?null:new tb(r,t,n,o),()=>t,t=>new n0(t,e),t=>t===e?n:null,ef,ef);return n}class n0 extends t${constructor(e,t){super(e),z(this,"literal"),this.literal=t}}let n1=nK(void 0);nq.push(e=>void 0===e?n1:void 0);let n3=nK(null);nq.push(e=>null===e?n3:void 0);let n4=new tO(M.Primitive,(e,t,n)=>"boolean"==typeof e?null:new tb(t,"boolean",e,n),()=>"boolean",e=>new n6(e),e=>"boolean"==typeof e?n4:null,ef,ef);nq.push(e=>e===Boolean?n4:void 0);class n6 extends t${}let n2=new tO(M.Primitive,(e,t,n)=>"number"==typeof e?null:new tb(t,"number",e,n),()=>"number",e=>new n8(e),e=>"number"==typeof e?n2:null,ef,ef);nq.push(e=>e===Number?n2:void 0);class n8 extends t${}let n5=new tO(M.Primitive,(e,t,n)=>"string"==typeof e?null:new tb(t,"string",e,n),()=>"string",e=>new n9(e),e=>"string"==typeof e?n5:null,ef,ef);nq.push(e=>e===String?n5:void 0);class n9 extends t${}let n7=!1,re=[];function rt(e){re.push(e)}function rn(e){for(let t of(n7||(n7=!0,rt(e=>ry(e)?nY(e):void 0),rt(e=>nG(e)?nQ(e):void 0),nq.forEach(e=>{rt(e)})),re)){let n=t(e);if(n)return n}}function rr(e){let t=e;for(;;){if(t instanceof tO)return t;if(tC(t))t=t();else{let t=rn(e);if(t)return rr(t);throw H("type checker could not be resolved")}}}function ro(e){return e instanceof tO||tC(e)?e:rn(e)||void 0}function rs(e){let t=ro(e);if(t)return t;throw H("standard type could not be resolved")}function ra(e,t){let n,r=ef;if(arguments.length>=2?(r=rr(e).toSnapshotProcessor,n=t):n=e,K(n))return r(n);eN(n,"nodeOrPrimitive");let o=tP(n);if(!o)throw H("getSnapshot is not supported for this kind of object");return tI(o.transformed),o.atom||(o.atom=(0,F.createAtom)("snapshot")),o.atom.reportObserved(),r(o.transformed)}let rl=(0,F.action)("newModel",(e,t,n)=>{let{modelInfo:r,modelIdPropertyName:o,modelProps:s,modelIdPropData:a}=ru(n);if(o&&a){let e;e=t[o]?t[o]:a._defaultFn(),tW(t,o,e)}e[B]=r.name;let l=Object.keys(s);for(let n=0;n<l.length;n++){let r=l[n];if(r===o)continue;let a=s[r],i=t[r],u=!1;if(a._transform&&(u=!0,i=a._transform.untransform(i,e,r)),null==i){let e=eQ(a);e!==eU?(u=!0,i=e):r in t||(u=!0)}u&&(0,F.set)(t,r,i)}if(rc(e,t,n),eq()&&tr(n).dataType){let t=e.typeCheck();t&&t.throw()}}),ri=(0,F.action)("fromSnapshotModel",(e,t,n,r)=>{let o;let{modelInfo:s,modelIdPropertyName:a,modelProps:l,modelIdPropData:i}=ru(n),u=t.unprocessedSnapshot;i&&a&&(o=r?i._defaultFn():u[a]),n.fromSnapshotProcessor&&(u=n.fromSnapshotProcessor(u));let c=t.snapshotToInitialData(u);e[B]=s.name;let h=[],d=[];if(a){var f;let e=c[a];if(f=o,(c[a]!==f||!(a in c))&&((0,F.set)(c,a,f),1)){let t=[a];h.push(tz(t,e,o)),d.push(tz(t,o,e))}}let p=Object.keys(l);for(let e=0;e<p.length;e++){let t=p[e];if(t===a)continue;let n=l[t],r=c[t],o=r,s=!1;if(null==o){let e=eQ(n);e!==eU?(s=!0,o=e):t in c||(s=!0)}if(s&&((0,F.set)(c,t,o),o!==r)){let e=[t];h.push(tz(e,r,o)),d.push(tz(e,o,r))}}let y=null==t?void 0:t.unprocessedModelType,m=s.name;if(y!==m){let e=[B];h.push(tz(e,y,m)),d.push(tz(e,m,y))}if(rc(e,c,n),tR(e,h,d),eq()&&tr(n).dataType){let t=e.typeCheck();t&&t.throw()}});function ru(e){let t=eO.get(e);if(!t)throw H(`no model info for class ${e.name} could be found - did you forget to add the @model decorator?`);let n=ts(e),r=e[eE],o=n?r[n]:void 0;return{modelInfo:t,modelIdPropertyName:n,modelProps:r,modelIdPropData:o}}function rc(e,t,n){nA(e,void 0),e.$=nf(t,{parent:e,path:"$"},e[B],!1,!0),nV(n,e)}let rh=Symbol("modelIdPropertyName");class rd{constructor(e){z(this,S),z(this,w),z(this,g),z(this,b),z(this,v),z(this,"$");let{snapshotInitialData:t,modelClass:n,generateNewIds:r}=arguments[1];Object.setPrototypeOf(this,n.prototype),delete this[ev],delete this[eb],delete this[eg],delete this[rh],t?ri(this,t,n,!!r):(er(e,"initialData"),rl(this,F.observable.object(e,void 0,{deep:!1}),n))}get[(S=ev,w=eb,g=eg,b=rh,v=B,J)](){let e=ts(this.constructor);return e?this.$[e]:void 0}set[J](e){let t=ts(this.constructor);if(!t)throw H("$modelId cannot be set when there is no idProp set in the model");this.$[t]=e}getRefId(){return this[J]}typeCheck(){return nP(nY(this.constructor),this)}toString(e){let t={withData:!0,...e},n=`${this.constructor.name}#${this[B]}`;return t.withData?`[${n} ${JSON.stringify(ra(this))}]`:`[${n}]`}}let rf=new Set([B,J,"onInit","$","getRefId","onAttachedToRootStore","typeCheck"]);function rp(e){return e instanceof rd}function ry(e){return"function"==typeof e&&(e===rd||e.prototype instanceof rd)}function rm(e){return Z(e)&&B in e}function rv(e,t){return t&&function(e){ek(eC,e,e$).reportObserved()}(e),ej.get(e)}function rb(e,t){let n=e_.get(e);if(n)return{parent:n,path:"$"};let r=rv(e,t);return r&&rp(r.parent)?{parent:r.parent.$,path:r.path}:r}function rg(e){return eN(e,"value"),rw(e,!0)}function rw(e,t){var n;return null==(n=rv(e,t))?void 0:n.parent}function rS(e){return eN(e,"value",!0),e_.has(e)}function rO(e,t){let n,r=e;for(;n=rv(r,t);)r=n.parent;return r}let rk={resolved:!1};function rj(e,t){let n=e,r=t.length;for(let e=0;e<r;e++){if(!q(n))return rk;let r=t[e];if(en(n)&&+r>=n.length)return rk;if(rp(n)){let e=eA(n);if(r in e)n=e;else if(!(r in n))return rk}n=n[r]}return{resolved:!0,value:n}}let rC=Symbol("skipIdChecking");function r$(e,t,n){var r;let o=eA(e),s=t.length;for(let e=0;e<s;e++){if(!q(o))return{resolved:!1};let s=t[e];if(en(o)&&+s>=o.length)return{resolved:!1};let a=o[s];o=eA(a);let l=n[e];if(l!==rC&&l!==(rp(a)&&null!=(r=a[J])?r:null))return{resolved:!1}}return{resolved:!0,value:eP(o)}}let rT=new WeakMap;function r_({nameOrNameFn:e,fn:t,actionType:n,overrideContext:o,isFlowFinisher:s=!1}){let a=!1,l=function(...l){let i="function"==typeof e?e():e;a||(a=!0,t=(0,F.action)(i,t));let u={actionName:i,type:n,target:this,args:l,parentContext:r,data:{},rootContext:void 0};o&&o(u,this),u.rootContext||(u.previousAsyncStepContext?u.rootContext=u.previousAsyncStepContext.rootContext:u.parentContext?u.rootContext=u.parentContext.rootContext:u.rootContext=u),r=u;let c=function(e){let t=[],n=e;for(;n;){let e=rT.get(n);e&&e.length>0&&t.push(e),n=rw(n,!1)}return t}(u.target),h=c.length-1,d=0,f=()=>{let e=c[h];if(!e)return t.apply(this,l);let n=e[d];return++d>=e.length&&(d=0,h--),!n.filter||n.filter(u)?n.middleware(u,f):f()};try{let e=f();if(!s)return e;{let t=e.value;return"accept"===e.resolution?e.accepter(t):e.rejecter(t),t}}finally{r=u.parentContext,function(){if(!r&&!tn){tn=!0;try{for(;tt.length>0;)tt.shift()()}finally{tn=!1}}}()}};return l[G]=!0,l}function rP(e,t,n){let r=e[t];if(L(r))return;let o=r_({nameOrNameFn:n,fn:r,actionType:T.Sync}),s=Object.getPrototypeOf(e);s[t]===r?s[t]=o:e[t]=o}function rA(e){eN(e,"node"),rx().call(e)}let rx=ed(()=>r_({nameOrNameFn:$.Detach,fn:rM,actionType:T.Sync}));function rM(){let e=rb(this,!1);if(!e)return;let{parent:t,path:n}=e;if((0,F.isObservableArray)(t))t.splice(+n,1);else if((0,F.isObservableObject)(t))(0,F.remove)(t,String(n));else throw H("parent must be an observable object or an observable array")}let rI=Symbol("unboundMethod"),rN=(e,t)=>{let n=rI in e?e[rI]:e,r=n.bind(t);return Object.getOwnPropertySymbols(n).forEach(e=>{r[e]=n[e]}),r[rI]=n,r},rD=(e,t)=>{e.target=t.$};function rR(e,t,n){if(!(nG(e)||nW(e)))return{actionName:t,overrideContext:void 0};{let r;let o=nG(e)?e:e.constructor,s=e=>{var n,o;let s=eO.get(e);n=r=`fn::${s.name}::${t}`,o=s.class,W.set(n,{modelClass:o,fnName:t})};return n?ei(o,eF,s):s(o),{actionName:()=>r,overrideContext:rD}}}let rV=Symbol("modelFlow"),rF=new Map;function rE(e){(0,F.remove)(this,String(e))}function rU(e,t){return this[e](...t)}function rz(e,t,n){eN(e,"node",!0),rG().call(e,t,n)}function rW(e,t){!rp(this)&&(0,F.isObservable)(this)?tW(this,e,t):this[e]=t}ed(()=>r_({nameOrNameFn:$.ApplyDelete,fn:rE,actionType:T.Sync})),ed(()=>r_({nameOrNameFn:$.ApplyMethodCall,fn:rU,actionType:T.Sync}));let rG=ed(()=>r_({nameOrNameFn:$.ApplySet,fn:rW,actionType:T.Sync}));function rL(...e){return function(e,t,n){if("object"!=typeof t[1]){let r=t[0],o=t[1],s=t[2],a=rR(r,o,!0),l=()=>{ei(r,ea,e=>{let t=n(a,e[o]);e[o]=rN(t,e)})};if(s){if(void 0!==s.get)throw H(`@${e} cannot be used with getters`);if(s.value)return{enumerable:!1,writable:!0,configurable:!0,value:n(a,s.value)};l()}else l()}else{let r=t[1];switch(r.name,r.static,r.kind){case"method":{let e=t[0],o=r.name,s=!1;r.addInitializer(function(){if(s)return;s=!0;let t=this,r=Object.getPrototypeOf(t);for(;r&&r[o]===e;)r=Object.getPrototypeOf(t=r);t[o]=n(rR(this,o,!1),t[o])});break}case"field":{let e;let t=r.name;return function(r){return e||(e=rR(this,t,!1)),rN(n(e,r),this)}}default:throw H(`@${e} can only be used on fields or methods}`)}}}("modelAction",e,(e,t)=>{if(L(t))return t;if("function"!=typeof t)throw H("modelAction has to be used over functions");return r_({nameOrNameFn:e.actionName,fn:t,actionType:T.Sync,overrideContext:e.overrideContext})})}function rB(e,t,n,r){var o,s=arguments.length,a=s<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,n,r);else for(var l=e.length-1;l>=0;l--)(o=e[l])&&(a=(s<3?o(a):s>3?o(t,n,a):o(t,n))||a);return s>3&&a&&Object.defineProperty(t,n,a),a}$.ApplySnapshot,$.ApplyPatches,$.Detach,$.ApplySet,$.ApplyDelete,$.ApplyMethodCall,Symbol("cannotSerialize"),(y=R||(R={})).Return="return",y.Throw="throw",Symbol("simpleDataContext"),"function"==typeof SuppressedError&&SuppressedError;class rJ extends t${constructor(e,t){super(e),z(this,"_objTypeFn"),z(this,"_props",ed(()=>{let e=this._objTypeFn(),t={};return Object.keys(e).forEach(n=>{let r=rs(e[n]);t[n]={type:r,typeInfo:nB(r)}}),t})),this._objTypeFn=t}get props(){return this._props()}}let rQ=new tO(M.Any,null,()=>"any",e=>new rX(e),()=>rQ,ef,ef);function rH(){return rQ}class rX extends t${}class rY extends t${constructor(e,t){super(e),z(this,"orTypes"),z(this,"_orTypeInfos",ed(()=>this.orTypes.map(nB))),this.orTypes=t}get orTypeInfos(){return this._orTypeInfos()}}let rZ=Symbol("noDefaultValue"),rq=new WeakMap;function rK(e,t){var n,r;let o,s;switch(typeof e){case"string":return rK(n5,e);case"number":return rK(n2,e);case"boolean":return rK(n4,e)}let a=arguments.length>=2,l=rs(e);return n=a?t:rZ,r=()=>{let e=a?function(e,...t){let n;let r=t.slice(),o=ro(e);if(o?r.unshift(o):n=t=>rr(e(t)),r.length<=0)throw H("or type must have at least 1 possible type");let s=e=>new rY(e,r.map(rs));return tj(()=>{let e=r.map(rr);if(e.some(e=>e.unchecked))return rH();let t=(...t)=>e.map(e=>t.includes(e)?"...":e.getTypeName(...t,e)).join(" | "),o=new tO(e.some(t=>t.baseType!==e[0].baseType)?M.Any:e[0].baseType,(n,r,s)=>e.some(e=>!e.check(n,r,s))?null:new tb(r,t(o),n,s),t,s,t=>{let n=en(t)?M.Array:q(t)?M.Object:K(t)?M.Primitive:M.Any,r=e.filter(e=>e.baseType===n||e.baseType===M.Any);if(1===r.length&&r[0].baseType===n)return r[0];for(let e=0;e<r.length;e++){let n=r[e].snapshotType(t);if(n)return n}return null},e=>{let r=n?n(e):o.snapshotType(e);if(!r)throw H(`snapshot '${JSON.stringify(e)}' does not match the following type: ${t(o)}`);return r.fromSnapshotProcessor(e)},e=>{let r=n?n(e):o.snapshotType(e);if(!r)throw H(`snapshot '${JSON.stringify(e)}' does not match the following type: ${t(o)}`);return r.toSnapshotProcessor(e)});return o},s)}(l,n1,n3):l,n=Object.create(a?eG(t):eG());return Object.assign(n,{_typeChecker:l,_fromSnapshotProcessor:r0.bind(void 0,e),_toSnapshotProcessor:r1.bind(void 0,l)}),n},(o=rq.get(l))||(o=new Map,rq.set(l,o)),(s=o.get(n))||(s=r(),o.set(n,s)),s}function r0(e,t){let n=rr(e).fromSnapshotProcessor;return n?n(t):t}function r1(e,t){let n=rr(e).toSnapshotProcessor;return n?n(t):t}function r3(...e){let t=e.filter(e=>!!e);if(!(t.length<=0))return(e,...n)=>{let r=e;for(let e=0;e<t.length;e++)r=t[e](r,...n);return r}}function r4(e,t,n="must be a class or data model class"){if(!ry(e)&&!nG(e))throw H(`${t} ${n}`)}let r6=(e,t,n,o)=>{if("assign"===e._setter&&!r){rz(n,t,o);return}let s=e._transform?e._transform.untransform(o,n,t):o;if(null==s){let t=eQ(e);t!==eU&&(s=t)}n.$[t]=s},r2=(e,t,n,r)=>!!n[ew]&&(r6(e,t,n,r),!0),r8=()=>eY.modelIdGenerator(),r5=rK(n5,r8);r5._isId=!0;let r9=eG(r8);function r7(e,t){var n;return function({modelProps:e,baseModel:t,type:n,valueType:r,fromSnapshotProcessor:o,toSnapshotProcessor:s}){var a,l,i;let u,c,h;if(er(e,"modelProps"),e=Object.assign(Object.create(null),e),t){r4(t,"baseModel");let e=t[eV];e&&r4(t=e,"baseModel")}let d=e;if(t){let n=t[eE];for(let t of Object.keys(n))e[t]||(d[t]=n[t])}let f=Object.keys(d).filter(e=>d[e]._isId);if("class"===n){if(f.length>1)throw H(`expected at most one idProp but got many: ${JSON.stringify(f)}`)}else if(f.length>=1)throw H(`expected no idProp but got some: ${JSON.stringify(f)}`);let p=Object.values(d).some(e=>!!e._typeChecker);if(f.length>=1){let e=d[u=f[0]],t=p?r5:r9;switch(e._setter){case!0:t=t.withSetter();break;case"assign":t=t.withSetter("assign")}d[u]=t}if(p){let e={};for(let[t,n]of Object.entries(d))e[t]=n._typeChecker?n._typeChecker:rH();l=a=()=>e,i=e=>new rJ(e,a),es(l,"objFn"),c=tj(()=>{let e=l();er(e,"objectSchema");let t=Object.entries(e),n=(...e)=>{let n=[];for(let[r,o]of t){let t=rr(o),s="...";e.includes(t)||(s=t.getTypeName(...e,t)),n.push(`${r}: ${s};`)}return`{ ${n.join(" ")} }`},r=(t,n)=>{let r={},o=Object.keys(t);for(let s=0;s<o.length;s++){let a=o[s],l=e[a];if(l){let e=rr(l);r[a]="from"===n?e.fromSnapshotProcessor(t[a]):e.toSnapshotProcessor(t[a])}else r[a]=t[a]}return r},o=new tO(M.Object,(e,r,s)=>{if(!q(e))return new tb(r,n(o),e,s);for(let[n,o]of t){let t=rr(o),a=e[n],l=t.check(a,[...r,n],s);if(l)return l}return null},n,i,e=>{if(!q(e))return null;for(let[n,r]of t){let t=rr(r),o=e[n];if(!t.snapshotType(o))return null}return o},e=>r(e,"from"),e=>r(e,"to"));return o},i)}let y=null!=t?t:"class"===n?rd:nU,m="class"===n?rf:nz;function v(t,n){var r;let o=null!=(r=null==n?void 0:n.modelClass)?r:this.constructor,s=new y(t,{...n,modelClass:o});return Y(s,ew,!1,!0),h||(h=Object.keys(e).filter(e=>!m.has(e)&&Object.hasOwn(s,e))),h.forEach(e=>{delete s[e]}),s}Object.assign(v,y);let b=y[nR];if(b&&(v[nR]=b.slice()),v[eE]=d,"class"===n){let e={dataType:c,modelIdProperty:u,valueType:r};v[eR]=e}else{let e={dataType:c};v[eR]=e}v.prototype=Object.create(y.prototype),v.prototype.constructor=v;let g=(e,t,n,r)=>{r2(e,t,n,r)&&(g=r6)};for(let[t,n]of Object.entries(e)){if(!m.has(t)){let e=function(e,t){var n;let r=null==(n=e._transform)?void 0:n.transform;if(!r)return function(){return this.$[t]};let o=(e,n)=>r(n,e,t,n=>{rz(e.$,t,n)});return function(){return o(this,this.$[t])}}(n,t);Object.defineProperty(v.prototype,t,{get:e,set(e){g(n,t,this,e)},enumerable:!0,configurable:!1})}if(!0===n._setter){let e=`set${t[0].toUpperCase()}${t.slice(1)}`;if(!m.has(e)){let n=rL(v.prototype,e,{value:function(e){this[t]=e},writable:!0,enumerable:!1,configurable:!1});Object.defineProperty(v.prototype,e,n)}}}let w=function(e){let t=Object.entries(e).filter(([e,t])=>t._fromSnapshotProcessor);if(!(t.length<=0))return e=>{let n={...e};for(let[r,o]of t)o._fromSnapshotProcessor&&(n[r]=o._fromSnapshotProcessor(e[r]));return n}}(d),S=function(e){let t=Object.entries(e).filter(([e,t])=>t._toSnapshotProcessor);if(!(t.length<=0))return e=>{let n={...e};for(let[r,o]of t)o._toSnapshotProcessor&&(n[r]=o._toSnapshotProcessor(e[r]));return n}}(d);if(o){let e=o;o=t=>({...e(t),[B]:t[B]})}if(s){let e=s;s=(t,n)=>({...e(t,n),[B]:t[B]})}return v.fromSnapshotProcessor=r3(o,w),v.toSnapshotProcessor=r3(S,s),v}({modelProps:"function"==typeof e?e():e,baseModel:void 0,type:"class",valueType:null!=(n=null==t?void 0:t.valueType)&&n,fromSnapshotProcessor:null==t?void 0:t.fromSnapshotProcessor,toSnapshotProcessor:null==t?void 0:t.toSnapshotProcessor})}r9._isId=!0;let oe=e=>(t,...n)=>{let r="object"==typeof n[1]?n[1]:void 0;return oo(e,t,null==r?void 0:r.addInitializer)},ot=new WeakMap,on=(e,t)=>{eu(t,ea);let n=ot.get(e);if(n.needsMakeObservable)ep.makeObservable(t);else if(void 0===n.needsMakeObservable){if(ey()>=6)try{ep.makeObservable(t),n.needsMakeObservable=!0}catch(e){if("[MobX] No annotations were passed to makeObservable, but no decorator members have been found either"!==e.message&&"[MobX] No annotations were passed to makeObservable, but no decorated members have been found either"!==e.message)throw e;n.needsMakeObservable=!1}else n.needsMakeObservable=!1}t[ew]=!0,eu(t,el),"class"===n.type&&t.onInit&&(rP(t,"onInit",A.OnInit),t.onInit()),"data"===n.type&&t.onLazyInit&&(rP(t,"onLazyInit",A.OnLazyInit),t.onLazyInit())},or={construct(e,t){let n=new e(...t);return on(e,n),n}},oo=(e,t,n)=>{let r=ry(t)?"class":nG(t)?"data":void 0;if(!r)throw H("clazz must be a class that extends from Model/DataModel");if(eS[e]&&eY.showDuplicateModelNameWarnings&&eh("warn",`a model with name "${e}" already exists (if you are using hot-reloading you may safely ignore this warning)`,`duplicateModelName - ${e}`),eV in t&&t[eV]===t)throw H("a class already decorated with `@model` cannot be re-decorated");if(t.toString=()=>`class ${t.name}#${e}`,"class"===r&&(t[B]=e),ot.set(t,{needsMakeObservable:void 0,type:r}),n){n(function(){on(t,this)});let r={name:e,class:t};eS[e]=r,eO.set(t,r),eu(t,eF);return}{let n=new Proxy(t,or);n.prototype.constructor=n,n[eV]=t;let r={name:e,class:n};return eS[e]=r,eO.set(n,r),eO.set(t,r),eu(t,eF),n}};function os(e){let t=t=>new oa(t,rs(e));return tj(()=>{let n=rr(e),r=(...e)=>`Array<${n.getTypeName(...e,n)}>`,o=new tO(M.Array,(e,t,s)=>{if(!en(e))return new tb(t,r(o),e,s);if(!n.unchecked)for(let r=0;r<e.length;r++){let o=n.check(e[r],[...t,r],s);if(o)return o}return null},r,t,e=>{if(!en(e))return null;if(!n.unchecked){for(let t=0;t<e.length;t++)if(!n.snapshotType(e[t]))return null}return o},e=>n.unchecked?e:e.map(e=>n.fromSnapshotProcessor(e)),e=>n.unchecked?e:e.map(e=>n.toSnapshotProcessor(e)));return o},t)}class oa extends t${constructor(e,t){super(e),z(this,"itemType"),this.itemType=t}get itemTypeInfo(){return nB(this.itemType)}}function ol(e,t){if(e.type===V.Single)return[e];{let n=[];for(let r of e.events)t?n.unshift(...ol(r,!0)):n.push(...ol(r,!1));return n}}(m=V||(V={})).Single="single",m.Group="group";let oi=class extends r7({undoEvents:rK(os(rH()),()=>[]),redoEvents:rK(os(rH()),()=>[])}){constructor(){super(...arguments),z(this,"_groupStack",[])}_clearUndo(){oh(()=>{this.undoEvents.length=0})}_clearRedo(){oh(()=>{this.redoEvents.length=0})}enforceMaxLevels({maxUndoLevels:e,maxRedoLevels:t}){if(void 0!==e)for(;this.undoEvents.length>e;)this.undoEvents.shift();if(void 0!==t)for(;this.redoEvents.length>t;)this.redoEvents.shift()}_undo({maxRedoLevels:e}){oh(()=>{let t=this.undoEvents.pop();this.redoEvents.push(t),this.enforceMaxLevels({maxRedoLevels:e})})}_redo({maxUndoLevels:e}){oh(()=>{let t=this.redoEvents.pop();this.undoEvents.push(t),this.enforceMaxLevels({maxUndoLevels:e})})}_addUndo({event:e,maxUndoLevels:t}){oh(()=>{this.undoEvents.push(e),this.redoEvents.length=0,this.enforceMaxLevels({maxUndoLevels:t})})}_addUndoToParentGroup(e,t){e.events.push(t)}get _currentGroup(){return this._groupStack[this._groupStack.length-1]}_startGroup(e,t,n){var r;let o=!1,s=!1,a=this._currentGroup,l={type:V.Group,groupName:e,events:[]},i=a?void 0:null==(r=null==n?void 0:n.attachedState)?void 0:r.save(),u={pause:()=>{if(s)throw H("cannot pause a group when it is already ended");if(!o)throw H("cannot pause a group when it is not running");if(this._currentGroup!==l)throw H("group out of order");this._groupStack.pop(),o=!1},resume:()=>{if(s)throw H("cannot resume a group when it is already ended");if(o)throw H("cannot resume a group when it is already running");this._groupStack.push(l),o=!0},end:()=>{var e;o&&u.pause(),s=!0,a?this._addUndoToParentGroup(a,l):this._addUndo({event:{...l,attachedState:{beforeEvent:i,afterEvent:null==(e=null==n?void 0:n.attachedState)?void 0:e.save()}},maxUndoLevels:null==n?void 0:n.maxUndoLevels})}};return t&&u.resume(),u}};rB([rL],oi.prototype,"_clearUndo",null),rB([rL],oi.prototype,"_clearRedo",null),rB([rL],oi.prototype,"_undo",null),rB([rL],oi.prototype,"_redo",null),rB([rL],oi.prototype,"_addUndo",null),oi=rB([oe(`${em}/UndoStore`)],oi);class ou{constructor(e,t,n,r){z(this,"disposer"),z(this,"subtreeRoot"),z(this,"options"),z(this,"store"),z(this,"_isUndoRecordingDisabled",!1),this.disposer=e,this.subtreeRoot=t,this.options=r,ey()>=6&&ep.makeObservable(this),this.store=null!=n?n:new oi({})}get undoQueue(){return this.store.undoEvents}get redoQueue(){return this.store.redoEvents}get undoLevels(){return this.undoQueue.length}get canUndo(){return this.undoLevels>0}clearUndo(){this.store._clearUndo()}get redoLevels(){return this.redoQueue.length}get canRedo(){return this.redoLevels>0}clearRedo(){this.store._clearRedo()}undo(){var e;if(!this.canUndo)throw H("nothing to undo");let t=this.undoQueue[this.undoQueue.length-1];oh(()=>{var e,n,r;ol(t,!0).forEach(e=>{ne(this.subtreeRoot,e.inversePatches,!0)}),(null==(e=t.attachedState)?void 0:e.beforeEvent)&&(null==(r=null==(n=this.options)?void 0:n.attachedState)||r.restore(t.attachedState.beforeEvent))}),this.store._undo({maxRedoLevels:null==(e=this.options)?void 0:e.maxRedoLevels})}redo(){var e;if(!this.canRedo)throw H("nothing to redo");let t=this.redoQueue[this.redoQueue.length-1];oh(()=>{var e,n,r;ol(t,!1).forEach(e=>{ne(this.subtreeRoot,e.patches)}),(null==(e=t.attachedState)?void 0:e.afterEvent)&&(null==(r=null==(n=this.options)?void 0:n.attachedState)||r.restore(t.attachedState.afterEvent))}),this.store._redo({maxUndoLevels:null==(e=this.options)?void 0:e.maxUndoLevels})}dispose(){this.disposer()}get isUndoRecordingDisabled(){return this._isUndoRecordingDisabled}withoutUndo(e){let t=this._isUndoRecordingDisabled;this._isUndoRecordingDisabled=!0;try{return e()}finally{this._isUndoRecordingDisabled=t}}createGroup(e){let t=this.store._startGroup(e,!1,this.options);return{continue(e){t.resume();try{return e()}finally{t.pause()}},end(){t.end()}}}withGroup(e,t){let n,r;"string"==typeof e?(n=e,r=t):r=e;let o=this.store._startGroup(n,!0,this.options);try{return r()}finally{o.end()}}withGroupFlow(e,t){let n,r;"string"==typeof e?(n=e,r=t):r=e;let o=r(),s=this.store._startGroup(n,!1,this.options),a=o.next.bind(o),l=o.throw.bind(o);return new Promise(function(e,t){function n(e){let n;s.resume();try{n=a(e)}catch(e){s.end(),t(e);return}s.pause(),o(n)}function r(e){let n;s.resume();try{n=l(e)}catch(e){s.end(),t(e);return}s.pause(),o(n)}function o(a){a&&"function"==typeof a.then?a.then(o,t):a.done?(s.end(),e(a.value)):Promise.resolve(a.value).then(n,r)}n(void 0)})}}rB([F.computed],ou.prototype,"undoQueue",null),rB([F.computed],ou.prototype,"redoQueue",null),rB([F.computed],ou.prototype,"undoLevels",null),rB([F.computed],ou.prototype,"canUndo",null),rB([F.action],ou.prototype,"clearUndo",null),rB([F.computed],ou.prototype,"redoLevels",null),rB([F.computed],ou.prototype,"canRedo",null),rB([F.action],ou.prototype,"clearRedo",null),rB([F.action],ou.prototype,"undo",null),rB([F.action],ou.prototype,"redo",null);let oc=!1;function oh(e){let t=oc;oc=!0;try{return e()}finally{oc=t}}function od(e){return"value"===e.type?e.value:e.value.get()}let of=()=>(0,F.createAtom)("contextValue");class op{constructor(e){z(this,"defaultContextValue",F.observable.box(void 0,{deep:!1})),z(this,"overrideContextValue",F.observable.box(void 0,{deep:!1})),z(this,"nodeContextValue",new WeakMap),z(this,"nodeAtom",new WeakMap),z(this,"setDefault",(0,F.action)(e=>{this.defaultContextValue.set({type:"value",value:e})})),z(this,"setDefaultComputed",(0,F.action)(e=>{this.defaultContextValue.set({type:"computed",value:(0,F.computed)(e)})})),z(this,"set",(0,F.action)((e,t)=>{eN(e,"node"),this.nodeContextValue.set(e,{type:"value",value:t}),this.reportNodeAtomChanged(e)})),z(this,"setComputed",(0,F.action)((e,t)=>{this._setComputed(e,(0,F.computed)(t))})),z(this,"unset",(0,F.action)(e=>{eN(e,"node"),this.nodeContextValue.delete(e),this.reportNodeAtomChanged(e)})),z(this,"apply",(0,F.action)((e,t)=>{let n=this.overrideContextValue.get();this.overrideContextValue.set({type:"value",value:t});try{let n=e();return eM(n,!0)&&this.set(n,t),n}finally{this.overrideContextValue.set(n)}})),z(this,"applyComputed",(0,F.action)((e,t)=>{let n=(0,F.computed)(t),r=this.overrideContextValue.get();this.overrideContextValue.set({type:"computed",value:n});try{let t=e();return eM(t,!0)&&this._setComputed(t,n),t}finally{this.overrideContextValue.set(r)}})),this.setDefault(e)}reportNodeAtomObserved(e){ek(this.nodeAtom,e,of).reportObserved()}reportNodeAtomChanged(e){var t;null==(t=this.nodeAtom.get(e))||t.reportChanged()}fastGet(e,t){t&&this.reportNodeAtomObserved(e);let n=this.nodeContextValue.get(e);if(n)return od(n);let r=rw(e,t);if(!r){let e=this.overrideContextValue.get();return e?od(e):this.getDefault()}return this.fastGet(r,t)}get(e){return eN(e,"node"),this.fastGet(e,!0)}fastGetProviderNode(e,t){if(t&&this.reportNodeAtomObserved(e),this.nodeContextValue.get(e))return e;let n=rw(e,t);if(n)return this.fastGetProviderNode(n,t)}getProviderNode(e){return eN(e,"node"),this.fastGetProviderNode(e,!0)}getDefault(){return od(this.defaultContextValue.get())}_setComputed(e,t){eN(e,"node"),this.nodeContextValue.set(e,{type:"computed",value:t}),this.reportNodeAtomChanged(e)}}new op(!1);class oy extends r7({id:rK(n5)}){get maybeCurrent(){return this.resolve()}get isValid(){return!!this.maybeCurrent}get current(){let e=this.maybeCurrent;if(!e)throw H(`a reference of type '${this[B]}' could not resolve an object with id '${this.id}'`);return e}}rB([F.computed],oy.prototype,"maybeCurrent",null),rB([F.computed],oy.prototype,"isValid",null),rB([F.computed],oy.prototype,"current",null);let om=new WeakMap;function ov(e,t,n,r){let o=class extends oy{constructor(){super(...arguments),z(this,"resolver"),z(this,"savedOldTarget")}resolve(){return this.resolver||(this.resolver=t(this)),this.resolver(this)}internalForceUpdateBackRefs(e){let t=this.savedOldTarget;this.savedOldTarget=e,oS(this,a,e,t)}forceUpdateBackRefs(){this.internalForceUpdateBackRefs(this.maybeCurrent)}onInit(){let e;let t=!0;(0,F.reaction)(()=>this.maybeCurrent,n=>{this.internalForceUpdateBackRefs(n);let o=e,s=t;e=n,t=!1,!s&&r&&n!==o&&r(this,n,o)},{fireImmediately:!0})}};rB([F.action],o.prototype,"forceUpdateBackRefs",null),o=rB([oe(e)],o);let s=e=>{let t;if("string"==typeof e?t=e:(er(e,"target"),t=n(e)),"string"!=typeof t)throw H("ref target object must have an id of string type");return new o({id:t})};s.refClass=o;let a=s;return a}function ob(e){if(rp(e)){let t=e.getRefId();if(void 0!==t&&"string"!=typeof t)throw H("'getRefId()' must return a string or undefined when present");return t}}let og=new WeakMap;function ow(e,t){let n=om.get(e);if(n||(n={all:F.observable.set(void 0,{deep:!1}),byType:new WeakMap},om.set(e,n)),!t)return n.all;{let e=n.byType.get(t);return e||(e=F.observable.set(void 0,{deep:!1}),n.byType.set(t,e)),e}}let oS=(0,F.action)("updateBackRefs",(e,t,n,r)=>{n!==r&&(r&&(ow(r).delete(e),ow(r,t).delete(e)),n&&(ow(n).add(e),ow(n,t).add(e)))});e9({initData:()=>({all:new Set,byType:new WeakMap}),addNode(e,t){e instanceof oy&&(t.all.add(e),ek(t.byType,e.constructor,()=>new Set).add(e))}});let oO=(0,F.action)("customRef",(e,t)=>{var n;return ov(e,()=>t.resolve,null!=(n=t.getId)?n:ob,t.onResolvedValueChange)});function ok(e,t){return function(e,t,n){if(es(t,e),rF.has(e)&&eh("warn",`an standalone action with name "${e}" already exists (if you are using hot-reloading you may safely ignore this warning)`,`duplicateActionName - ${e}`),L(t))throw H("the standalone action must not be previously marked as an action");if("function"==typeof t&&rV in t)throw H("the standalone action must not be previously marked as a flow action");let r=n?function({nameOrNameFn:e,generator:t,overrideContext:n}){let r=function(...r){let o;let s="function"==typeof e?e():e,a=this,l=e=>(t,s)=>{n&&n(t,s),t.previousAsyncStepContext=o,t.spawnAsyncStepContext=o?o.spawnAsyncStepContext:t,t.asyncStepType=e,t.args=r,o=t},i=!1,u=r_({nameOrNameFn:s,fn:()=>(i=!0,t.apply(a,r)),actionType:T.Async,overrideContext:l(_.Spawn)}).apply(a);if(!i)return u instanceof Promise?u:Promise.resolve(u);let c=u.next.bind(u),h=u.throw.bind(u);return new Promise(function(e,t){function n(n){let r;try{r=r_({nameOrNameFn:s,fn:c,actionType:T.Async,overrideContext:l(_.Resume)}).call(a,n)}catch(n){r_({nameOrNameFn:s,fn:n=>({value:n,resolution:"reject",accepter:e,rejecter:t}),actionType:T.Async,overrideContext:l(_.Throw),isFlowFinisher:!0}).call(a,n);return}o(r)}function r(n){let r;try{r=r_({nameOrNameFn:s,fn:h,actionType:T.Async,overrideContext:l(_.ResumeError)}).call(a,n)}catch(n){r_({nameOrNameFn:s,fn:n=>({value:n,resolution:"reject",accepter:e,rejecter:t}),actionType:T.Async,overrideContext:l(_.Throw),isFlowFinisher:!0}).call(a,n);return}o(r)}function o(i){i&&"function"==typeof i.then?i.then(o,t):i.done?r_({nameOrNameFn:s,fn:n=>({value:n,resolution:"accept",accepter:e,rejecter:t}),actionType:T.Async,overrideContext:l(_.Return),isFlowFinisher:!0}).call(a,i.value):Promise.resolve(i.value).then(n,r)}n(void 0)})};return r[rV]=!0,r}({nameOrNameFn:e,generator:t}):r_({nameOrNameFn:e,fn:t,actionType:T.Sync}),o=(e,...t)=>(!function(e,t="argument"){eN(e,t,!1)}(e,"target"),r.call(e,e,...t));return rF.set(e,o),o}(e,t,!1)}(0,F.action)("rootRef",(e,t)=>{var n;let r=null!=(n=null==t?void 0:t.getId)?n:ob;return ov(e,e=>{let t;return()=>{var n;let o=rO(e,!0);if((n=t)&&e.id===r(n)&&o===rO(n,!0))return t;let s=function(e,t,n=ob){let r=ek(og,n,()=>(function(e){let t=new WeakMap;return{walk:n=>(function e(t,n,r){let o=t.get(r);return o||(o=(0,F.computed)(()=>(function(e,t,n){let r;let o=t(e),s=e1(e),a=s.values(),l=a.next();if(void 0===o&&1===s.size)return n(l.value);for(;!l.done;){let e=n(l.value);if(e){r||(r=new Map);let t=e.keys(),n=t.next();for(;!n.done;){let o=n.value,s=e.get(o);r.set(o,s),n=t.next()}}l=a.next()}return void 0!==o&&(r||(r=new Map),r.set(o,e)),r})(r,n,r=>e(t,n,r))),t.set(r,o)),o.get()})(t,e,n)}})(e=>n(e))).walk(e);return r?r.get(t):void 0}(o,e.id,r);return s&&(t=s),s}},r,null==t?void 0:t.onResolvedValueChange)});let oj=`${em}/arrayActions`;ok(`${oj}::set`,(e,t,n)=>{tW(e,t,n)}),ok(`${oj}::delete`,(e,t)=>(0,F.remove)(e,String(t))),ok(`${oj}::setLength`,(e,t)=>{e.length=t}),ok(`${oj}::concat`,(e,...t)=>e.concat(...t)),ok(`${oj}::copyWithin`,(e,t,n,r)=>e.copyWithin(t,n,r)),ok(`${oj}::fill`,(e,t,n,r)=>e.fill(t,n,r)),ok(`${oj}::pop`,e=>e.pop()),ok(`${oj}::push`,(e,...t)=>e.push(...t)),ok(`${oj}::reverse`,e=>e.reverse()),ok(`${oj}::shift`,e=>e.shift()),ok(`${oj}::slice`,(e,t,n)=>e.slice(t,n)),ok(`${oj}::sort`,(e,t)=>e.sort(t)),ok(`${oj}::splice`,function(e,...t){return e.splice(...t)}),ok(`${oj}::unshift`,(e,...t)=>e.unshift(...t)),ok(`${oj}::swap`,(e,t,n)=>{if(t<0||n<0||t>=e.length||n>=e.length)return!1;n<t&&([t,n]=[n,t]);let[r]=e.splice(t,1),[o]=e.splice(n-1,1);return e.splice(t,0,o),e.splice(n,0,r),!0}),e=>nM(e);let oC=`${em}/objectActions`;function o$(e){let t=new WeakMap;return{for(n){if(t.has(n))return t.get(n);{let r=e(n);return t.set(n,r),r}}}}ok(`${oC}::set`,(e,t,n)=>{(0,F.isObservable)(e)?tW(e,t,n):e[t]=n}),ok(`${oC}::assign`,(e,t)=>{er(t,"partialObject");let n=Object.keys(t);if((0,F.isObservable)(e))for(let r of n){let n=t[r];tW(e,r,n)}else for(let r of n)e[r]=t[r]}),ok(`${oC}::delete`,(e,t)=>(0,F.remove)(e,t)),ok(`${oC}::call`,(e,t,...n)=>e[t](...n)),e=>nM(e);let oT=(0,F.action)(e=>{let t=F.observable.map();t.dataObject=e;let n=Object.keys(e);for(let r=0;r<n.length;r++){let o=n[r];t.set(o,e[o])}let r=!1,o=!1;return(0,F.observe)(e,(0,F.action)(e=>{if(!r){o=!0;try{switch(e.type){case"add":case"update":t.set(e.name,e.newValue);break;case"remove":t.delete(e.name)}}finally{o=!1}}})),(0,F.intercept)(t,(0,F.action)(t=>{if(r)return null;if(o)return t;r=!0;try{switch(t.type){case"add":case"update":tW(e,t.name,t.newValue);break;case"delete":(0,F.remove)(e,t.name)}return t}finally{r=!1}})),t}),o_=(0,F.action)(e=>{let t;if(ey()>=6?t=F.observable.map(e):(t=F.observable.map(),e.forEach(([e,n])=>{t.set(e,n)})),t.dataObject=e,t.size!==e.length)throw H("arrays backing a map cannot contain duplicate keys");let n=!1,r=!1;return(0,F.observe)(e,(0,F.action)(e=>{if(!n){r=!0;try{switch(e.type){case"splice":{let n=e.removed;for(let e=0;e<n.length;e++)t.delete(n[e][0])}{let n=e.added;for(let e=0;e<n.length;e++)t.set(n[e][0],n[e][1])}break;case"update":t.delete(e.oldValue[0]),t.set(e.newValue[0],e.newValue[1])}}finally{r=!1}}})),(0,F.intercept)(t,(0,F.action)(t=>{if(n)return null;if(r)return t;n=!0;try{switch(t.type){case"update":{let n=e.findIndex(e=>e[0]===t.name);e[n]=[t.name,t.newValue];break}case"add":e.push([t.name,t.newValue]);break;case"delete":{let n=e.findIndex(e=>e[0]===t.name);n>=0&&e.splice(n,1)}}return t}finally{n=!1}})),t});o$(e=>en(e)?(eo(e,"objOrArray"),o_(e)):(!function(e,t){if(!(0,F.isObservableObject)(e))throw H(`${t} must be an observable object`)}(e,"objOrArray"),oT(e)));let oP=(0,F.action)(e=>{let t;if(ey()>=6?t=F.observable.set(e):(t=F.observable.set(),e.forEach(e=>{t.add(e)})),t.dataObject=e,t.size!==e.length)throw H("arrays backing a set cannot contain duplicate values");let n=!1,r=!1;return(0,F.observe)(e,(0,F.action)(e=>{if(!n){r=!0;try{switch(e.type){case"splice":{let n=e.removed;for(let e=0;e<n.length;e++)t.delete(n[e])}{let n=e.added;for(let e=0;e<n.length;e++)t.add(n[e])}break;case"update":t.delete(e.oldValue),t.add(e.newValue)}}finally{r=!1}}})),(0,F.intercept)(t,(0,F.action)(t=>{if(n)return null;if(r)return t;n=!0;try{switch(t.type){case"add":e.push(t.newValue);break;case"delete":{let n=e.indexOf(t.oldValue);n>=0&&e.splice(n,1)}}return t}finally{n=!1}})),t});o$(e=>(eo(e,"array"),oP(e)));let oA="this Date object is immutable";class ox extends Date{setTime(){throw H(oA)}setMilliseconds(){throw H(oA)}setUTCMilliseconds(){throw H(oA)}setSeconds(){throw H(oA)}setUTCSeconds(){throw H(oA)}setMinutes(){throw H(oA)}setUTCMinutes(){throw H(oA)}setHours(){throw H(oA)}setUTCHours(){throw H(oA)}setDate(){throw H(oA)}setUTCDate(){throw H(oA)}setMonth(){throw H(oA)}setUTCMonth(){throw H(oA)}setFullYear(){throw H(oA)}setUTCFullYear(){throw H(oA)}}let oM={transform:({originalValue:e,cachedTransformedValue:t})=>null!=t?t:new ox(e),untransform:({transformedValue:e,cacheTransformedValue:t})=>(e instanceof ox&&t(),+e)},oI=()=>oM;class oN{constructor(e){z(this,"data"),z(this,"originalData"),eN(e,"original"),this.originalData=e,this.data=nk(this.originalSnapshot,{generateNewIds:!1})}commit(){tK(this.originalData,ra(this.data))}commitByPath(e){let t=rj(this.data,e);if(!t.resolved)throw H(`path ${JSON.stringify(e)} could not be resolved in draft object`);let n=oD(this.data,e);if(!r$(this.originalData,e,n).resolved)throw H(`path ${JSON.stringify(e)} could not be resolved in original object`);ne(this.originalData,[{path:e,op:"replace",value:ra(t.value)}])}reset(){tK(this.data,this.originalSnapshot)}resetByPath(e){let t=rj(this.originalData,e);if(!t.resolved)throw H(`path ${JSON.stringify(e)} could not be resolved in original object`);let n=oD(this.originalData,e);if(!r$(this.data,e,n).resolved)throw H(`path ${JSON.stringify(e)} could not be resolved in draft object`);ne(this.data,[{path:e,op:"replace",value:ra(t.value)}])}get isDirty(){return!t4(ra(this.data),this.originalSnapshot)}isDirtyByPath(e){let t=rj(this.data,e);if(!t.resolved)throw H(`path ${JSON.stringify(e)} could not be resolved in draft object`);let n=oD(this.data,e),r=r$(this.originalData,e,n);return!r.resolved||!t4(t.value,r.value)}get originalSnapshot(){return ra(this.originalData)}}function oD(e,t){let n=function(e,t){var n;let r=[],o=e;for(let e=0;e<t.length;e++){let s=rp(o=o[t[e]])&&null!=(n=o[J])?n:null;r.push(s)}return r}(e,t);return n.length>=1&&(n[n.length-1]=rC),n}rB([F.action],oN.prototype,"commit",null),rB([F.action],oN.prototype,"commitByPath",null),rB([F.action],oN.prototype,"reset",null),rB([F.action],oN.prototype,"resetByPath",null),rB([F.computed],oN.prototype,"isDirty",null),rB([F.computed],oN.prototype,"originalSnapshot",null),new op(void 0);let oR=class extends r7({[J]:ez,items:rK(os(rH()),()=>[])}){constructor(){super(...arguments),z(this,O,"ArraySet")}add(e){let t=this.items;return t.includes(e)||t.push(e),this}clear(){this.items.length=0}delete(e){let t=this.items,n=t.findIndex(t=>t===e);return n>=0&&(t.splice(n,1),!0)}forEach(e,t){let n=this.items,r=n.length;for(let o=0;o<r;o++){let r=n[o];e.call(t,r,r,this)}}has(e){return this.items.includes(e)}get size(){return this.items.length}keys(){return this.values()}values(){let e=this.items;return(0,F.values)(e)[Symbol.iterator]()}entries(){return this.items.map(e=>[e,e]).values()}[(k=Symbol.iterator,O=Symbol.toStringTag,k)](){return this.values()}union(e){return new Set(this).union(e)}intersection(e){return new Set(this).intersection(e)}difference(e){return new Set(this).difference(e)}symmetricDifference(e){return new Set(this).symmetricDifference(e)}isSubsetOf(e){return new Set(this).isSubsetOf(e)}isSupersetOf(e){return new Set(this).isSupersetOf(e)}isDisjointFrom(e){return new Set(this).isDisjointFrom(e)}};function oV(e){let t=t=>new oF(t,rs(e));return tj(()=>{let n=rr(e),r=(...e)=>`Record<${n.getTypeName(...e,n)}>`,o=(e,t)=>{if(n.unchecked)return e;let r={},o=Object.keys(e);for(let s=0;s<o.length;s++){let a=o[s],l="from"===t?n.fromSnapshotProcessor(e[a]):n.toSnapshotProcessor(e[a]);r[a]=l}return r},s=new tO(M.Object,(e,t,o)=>{if(!q(e))return new tb(t,r(s),e,o);if(!n.unchecked){let r=Object.keys(e);for(let s=0;s<r.length;s++){let a=r[s],l=e[a],i=n.check(l,[...t,a],o);if(i)return i}}return null},r,t,e=>{if(!q(e))return null;if(!n.unchecked){let t=Object.keys(e);for(let r=0;r<t.length;r++){let o=e[t[r]];if(!n.snapshotType(o))return null}}return s},e=>o(e,"from"),e=>o(e,"to"));return s},t)}rB([rL],oR.prototype,"add",null),rB([rL],oR.prototype,"clear",null),rB([rL],oR.prototype,"delete",null),oR=rB([oe(`${em}/ArraySet`)],oR);class oF extends t${constructor(e,t){super(e),z(this,"valueType"),this.valueType=t}get valueTypeInfo(){return nB(this.valueType)}}let oE=class extends r7({[J]:ez,items:rK(oV(rH()),()=>({}))}){constructor(){super(...arguments),z(this,j,"ObjectMap")}clear(){let e=this.items,t=Object.keys(e),n=t.length;for(let r=0;r<n;r++){let n=t[r];(0,F.remove)(e,n)}}delete(e){return!!this.has(e)&&((0,F.remove)(this.items,e),!0)}forEach(e,t){let n=this.items,r=Object.keys(n),o=r.length;for(let s=0;s<o;s++){let o=r[s];e.call(t,n[o],o,this)}}get(e){return(0,F.get)(this.items,e)}has(e){return(0,F.has)(this.items,e)}set(e,t){return tW(this.items,e,t),this}get size(){return(0,F.keys)(this.items).length}keys(){return(0,F.keys)(this.items)[Symbol.iterator]()}values(){return(0,F.values)(this.items)[Symbol.iterator]()}entries(){return(0,F.entries)(this.items)[Symbol.iterator]()}[(C=Symbol.iterator,j=Symbol.toStringTag,C)](){return this.entries()}};function oU(e,t,n){let r=r=>new oz(r,rs(e),t,n);return tj(()=>{let o=rr(e),s=(...e)=>{let t=o.getTypeName(...e,o),r=n||"refinementOf";return`${r}<${t}>`},a=new tO(o.baseType,(e,n,r)=>{let l=o.check(e,n,r);if(l)return l;let i=t(e);return!0===i||null==i?null:!1===i?new tb(n,s(a),e,r):new tb(i.path,i.expectedTypeName,i.actualValue,r)},s,r,e=>o.snapshotType(e),e=>o.fromSnapshotProcessor(e),e=>o.toSnapshotProcessor(e));return a},r)}rB([rL],oE.prototype,"clear",null),rB([rL],oE.prototype,"delete",null),rB([rL],oE.prototype,"set",null),oE=rB([oe(`${em}/ObjectMap`)],oE);class oz extends t${constructor(e,t,n,r){super(e),z(this,"baseType"),z(this,"checkFunction"),z(this,"typeName"),this.baseType=t,this.checkFunction=n,this.typeName=r}get baseTypeInfo(){return nB(this.baseType)}}oU(n2,e=>Number.isInteger(e),"integer"),oU(n5,e=>""!==e,"nonEmpty")}}]);